from aiogram import Bot, Dispatcher, types
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
import logging
import aiohttp
from bs4 import BeautifulSoup
import asyncio
import os

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

BOT_TOKEN = 'YOUR_BOT_TOKEN'
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

user_data = {}

DONATE_URL = "https://www.donationalerts.com/r/black_h0le_d"  # –°—Å—ã–ª–∫–∞ –Ω–∞ –¥–æ–Ω–∞—Ç
RUTUBE_DOWNLOAD_SITE = "https://cobalt.tools/?url="  # –°–∞–π—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å Rutube


def save_user_query(chat_id: int, query: str):
    if chat_id not in user_data:
        user_data[chat_id] = {
            "history": [],
            "results": [],
            "index": 0,
            "type": None,
            "favorites": [],
            "settings": {"default_platform": None},
            "is_searching": False
        }
    if user_data[chat_id]["is_searching"]:
        user_data[chat_id]["history"].append(query)
        if len(user_data[chat_id]["history"]) > 10:
            user_data[chat_id]["history"] = user_data[chat_id]["history"][-10:]


def create_start_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å")]],
        resize_keyboard=True
    )


def create_main_menu():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üé• –í–∏–¥–µ–æ –Ω–∞ Rutube"), KeyboardButton(text="üéµ –ú—É–∑—ã–∫–∞ –Ω–∞ Bandcamp")],
            [KeyboardButton(text="‚≠ê –ò–∑–±—Ä–∞–Ω–Ω–æ–µ"), KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")],
            [KeyboardButton(text="üìú –ò—Å—Ç–æ—Ä–∏—è"), KeyboardButton(text="‚ùå –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é")],
            [KeyboardButton(text="‚ÑπÔ∏è –ü–æ–º–æ—â—å"), KeyboardButton(text="üí∞ –î–æ–Ω–∞—Ç")]  # –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ –¥–æ–Ω–∞—Ç–∞
        ],
        resize_keyboard=True
    )


@dp.message(Command("start"))
async def start_bot(message: types.Message):
    name = message.from_user.first_name
    username = message.from_user.username
    greeting = f"–ü—Ä–∏–≤–µ—Ç, {name}!" + (f" (@{username})" if username else "")
    await message.answer(greeting)
    await message.answer("–Ø –±–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–∏–¥–µ–æ –∏ –º—É–∑—ã–∫–∏. –ù–∞–∂–º–∏ ¬´‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å¬ª, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ç–∏–ø –ø–æ–∏—Å–∫–∞.",
                         reply_markup=create_start_keyboard())


@dp.message(lambda message: message.text == "‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å")
async def start_search(message: types.Message):
    await message.answer("–í—ã–±–µ—Ä–∏, —á—Ç–æ —Ç—ã —Ö–æ—á–µ—à—å –∏—Å–∫–∞—Ç—å:", reply_markup=create_main_menu())


@dp.message(lambda message: message.text in ["üé• –í–∏–¥–µ–æ –Ω–∞ Rutube", "üéµ –ú—É–∑—ã–∫–∞ –Ω–∞ Bandcamp"])
async def choose_search_type(message: types.Message):
    chat_id = message.chat.id
    if chat_id not in user_data:
        user_data[chat_id] = {
            "history": [],
            "results": [],
            "index": 0,
            "type": None,
            "favorites": [],
            "settings": {"default_platform": None},
            "is_searching": True
        }
    else:
        user_data[chat_id]["is_searching"] = True
    user_data[chat_id]["type"] = "video" if message.text == "üé• –í–∏–¥–µ–æ –Ω–∞ Rutube" else "music"
    await message.answer(
        f"–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —è –±—É–¥—É –∏—Å–∫–∞—Ç—å {'–≤–∏–¥–µ–æ –Ω–∞ Rutube' if user_data[chat_id]['type'] == 'video' else '–º—É–∑—ã–∫—É –Ω–∞ Bandcamp'}. –í–≤–µ–¥–∏ –∑–∞–ø—Ä–æ—Å:",
        reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")]], resize_keyboard=True))


@dp.message(lambda message: message.text == "üí∞ –î–æ–Ω–∞—Ç")
async def donate_handler(message: types.Message):
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üí∞ –ü–µ—Ä–µ–π—Ç–∏ –∫ –¥–æ–Ω–∞—Ç—É", url=DONATE_URL)]
        ]
    )
    await message.answer(
        "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É! –í–∞—à –≤–∫–ª–∞–¥ –ø–æ–º–æ–≥–∞–µ—Ç —Ä–∞–∑–≤–∏–≤–∞—Ç—å –ø—Ä–æ–µ–∫—Ç. –í—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å –¥–æ–Ω–∞—Ç, –Ω–∞–∂–∞–≤ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=keyboard
    )


@dp.message()
async def process_query(message: types.Message):
    chat_id = message.chat.id
    query = message.text.strip()
    if query == "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
        await return_to_menu(message)
        return
    if chat_id not in user_data or not user_data[chat_id]["type"]:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —Ç–∏–ø –ø–æ–∏—Å–∫–∞.", reply_markup=create_main_menu())
        return
    if user_data[chat_id]["is_searching"]:
        save_user_query(chat_id, query)
    if user_data[chat_id]["type"] == "video":
        results = await find_videos(query)
    elif user_data[chat_id]["type"] == "music":
        results = await find_music(query)
    if not results:
        await message.answer("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å.", reply_markup=create_main_menu())
        return
    user_data[chat_id]["results"] = results
    await show_results(chat_id, message)


async def find_videos(query: str):
    url = f"https://rutube.ru/api/search/video/?query={query}"
    headers = {"User-Agent": "Mozilla/5.0"}
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                data = await response.json()
                return [(item.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"), f"https://rutube.ru/video/{item.get('id')}/") for item in
                        data.get("results", [])]
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {response.status}")
    return []


async def find_music(query: str):
    url = f"https://bandcamp.com/search?q={query}"
    headers = {"User-Agent": "Mozilla/5.0"}
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                soup = BeautifulSoup(await response.text(), 'html.parser')
                return [(item.find('div', {'class': 'heading'}).text.strip(), item.find('a')['href']) for item in
                        soup.find_all('li', {'class': 'searchresult'})]
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {response.status}")
    return []


async def show_results(chat_id: int, message: types.Message = None):
    results = user_data[chat_id]["results"]
    if not results:
        await bot.send_message(chat_id, "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return
    max_results_to_show = 10
    total_results = len(results)
    pages = [results[i:i + max_results_to_show] for i in range(0, total_results, max_results_to_show)]
    current_page = user_data[chat_id].get("current_page", 0)
    user_data[chat_id]["current_page"] = current_page
    for idx, result in enumerate(pages[current_page], start=current_page * max_results_to_show + 1):
        text = f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç {idx}/{total_results}\n"
        text += f"üìå –ù–∞–∑–≤–∞–Ω–∏–µ: {result[0]}\nüîó –°—Å—ã–ª–∫–∞: {result[1]}"
        # –°–æ–∑–¥–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        if user_data[chat_id]["type"] == "video":  # Add download link only for videos
            if not result[1].startswith("http"):
                result[1] = f"https://rutube.ru{result[1]}"
            download_link = f"{RUTUBE_DOWNLOAD_SITE}{result[1]}"
            keyboard.inline_keyboard.append(
                [InlineKeyboardButton(text="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å", url=download_link)]
            )
        keyboard.inline_keyboard.append(
            [
                InlineKeyboardButton(text="‚≠ê –í –∏–∑–±—Ä–∞–Ω–Ω–æ–µ", callback_data=f"add_fav_{idx}"),
                InlineKeyboardButton(text="‚ùå –ó–∞–∫–æ–Ω—á–∏—Ç—å", callback_data="stop")
            ]
        )
        if message:
            await message.answer(text, parse_mode=ParseMode.HTML, reply_markup=keyboard)
        else:
            await bot.send_message(chat_id, text, parse_mode=ParseMode.HTML, reply_markup=keyboard)
    # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é, –µ—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    if len(pages) > 1:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        if current_page > 0:
            keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data="prev_page")])
        if current_page < len(pages) - 1:
            keyboard.inline_keyboard.append([InlineKeyboardButton(text="–°–ª–µ–¥—É—é—â–∞—è ‚Üí", callback_data="next_page")])
        if message:
            await message.answer("–î–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –º–µ–∂–¥—É —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º–∏:", reply_markup=keyboard)
        else:
            await bot.send_message(chat_id, "–î–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –º–µ–∂–¥—É —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º–∏:", reply_markup=keyboard)


@dp.callback_query(lambda c: c.data.startswith("add_fav_"))
async def add_to_favorites(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    index = int(callback.data.split("_")[2]) - 1
    result = user_data[chat_id]["results"][index]
    user_data[chat_id]["favorites"].append(result)
    await callback.answer("–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ!")


@dp.callback_query(lambda c: c.data == "prev_page")
async def prev_page(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    current_page = user_data[chat_id].get("current_page", 0)
    if current_page > 0:
        user_data[chat_id]["current_page"] -= 1
        await show_results(chat_id, callback.message)
    await callback.answer()


@dp.callback_query(lambda c: c.data == "next_page")
async def next_page(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    current_page = user_data[chat_id].get("current_page", 0)
    pages = [user_data[chat_id]["results"][i:i + 10] for i in range(0, len(user_data[chat_id]["results"]), 10)]
    if current_page < len(pages) - 1:
        user_data[chat_id]["current_page"] += 1
        await show_results(chat_id, callback.message)
    await callback.answer()


@dp.callback_query(lambda c: c.data == "stop")
async def stop_search(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    user_data[chat_id]["results"] = []
    user_data[chat_id]["index"] = 0
    await callback.answer("–ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à—ë–Ω.")
    await callback.message.answer("–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=create_main_menu())


@dp.message(lambda message: message.text == "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
async def return_to_menu(message: types.Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        user_data[chat_id]["is_searching"] = False
    await message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=create_main_menu())


async def run_bot():
    try:
        logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
        await dp.start_polling(bot)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞: {e}")


if __name__ == '__main__':
    asyncio.run(run_bot())
